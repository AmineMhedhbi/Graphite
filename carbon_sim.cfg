# Configuration file for the carbon simulator

# This file is organized into sections defined in [] brackets as in [section].
# Sections may be hierarchical withsub-sections split by the '/' character as
# in [section/sub_section].
#
# values can be "strings" , numbers, or true/false, existing values
# should indicate the type

# This section controls various high-level simulation parameters.
[general]
# This is the directory where the logs as well as the simulation
# result is stored.
output_dir = "./output_files/"

# This is the name of the file, under the output directory (defined
# above) that the statistics for each core are written to.
output_file = "sim.out"

# Total number of cores in the simulation
total_cores = 8

# This defines the number of processes that will used to
# perform the simulation
num_processes = 1

# these flags are used to disable certain sub-systems of
# the simulator and should only be used/changed for debugging
# purposes.
enable_dcache_modeling = true
enable_icache_modeling = false
enable_performance_modeling = true
enable_shared_mem = true
enable_syscall_modeling = true

# This option defines the ports on which the various processes will communicate
# in distributed simulations. Note that several ports will be used above this
# number for each process, thus requiring a port-range to be opened for
# distributed simulations.
[transport]
base_port = 2000

# This section is used to fine-tune the logging information. The logging may
# be disabled for performance runs or enabled for debugging.
[log]
enabled = false
stack_trace = false
disabled_modules = ""
#enabled_modules = "l1_cache_cntlr.cc memory_manager.cc network.cc core.cc"
enabled_modules = ""

[progress_trace]
enabled = false
interval = 5000

# this section defines the sychronization mechanism. For more information
# on tradeoffs between the different synchronization schemes, see the
# Graphite paper from HPCA.
[clock_skew_minimization]
scheme = none  # Valid Schemes are 'none,barrier,random_pairs,ring'

# These are the various parameters used for each synchronization scheme
# with the comments defined inline
[clock_skew_minimization/barrier]
quantum = 1000    # Synchronize after every quantum
[clock_skew_minimization/random_pairs]
quantum = 100000   # Could be equal to slack but kept different for generality
slack = 100000
sleep_fraction = 0.4   # Equal to the fraction of computed time the core sleeps
[clock_skew_minimization/ring]
slack = 1000       # Messages could be sent on the ring after a delay. Not shown here

# Since the memory is emulated to ensure correctness on distributed simulations, we
# must manage a stack for each thread. These parameters control information about
# the stacks that are managed.
[stack]
stack_base = 2415919104 # this is the start address of the managed stacks
stack_size_per_core = 4194304 # this is the size of the stack

# The process map is used for multi-machine distributed simulations. Each process
# must have a hostname associated with it and this mapping below describes the
# mapping between processes and hosts. 
[process_map]
process0 = "127.0.0.1"
process1 = "127.0.0.1"
process2 = "127.0.0.1"
process3 = "127.0.0.1"
process4 = "127.0.0.1"
process5 = "127.0.0.1"
process6 = "127.0.0.1"
process7 = "127.0.0.1"
process8 = "127.0.0.1"
process9 = "127.0.0.1"
process10 = "127.0.0.1"
process11 = "127.0.0.1"
process12 = "127.0.0.1"
process13 = "127.0.0.1"
process14 = "127.0.0.1"
process15 = "127.0.0.1"
process16 = "127.0.0.1"

# This section describes parameters for the core model
[perf_model/core]
frequency = 3.16 # In GHz
type = simple 
num_store_buffer_entries = 20
num_outstanding_loads = 32

# This section describes the number of cycles for
# various arithmetic instructions.
[perf_model/core/static_instruction_costs]
add=1
sub=1
mul=3
div=18
fadd=3
fsub=3
fmul=5
fdiv=6
generic=1
jmp=1

[perf_model/l1_icache]
enable = true
cache_block_size = 64
cache_size = 32 # in KB
associativity = 8
replacement_policy = lru
data_access_time = 3
tags_access_time = 1
perf_model_type = parallel

[perf_model/l1_dcache]
enable = true
cache_block_size = 64
cache_size = 32 # in KB
associativity = 8
replacement_policy = lru 
data_access_time = 3
tags_access_time = 1
perf_model_type = parallel

[perf_model/l2_cache]
enable = true
cache_block_size = 64 # in bytes
cache_size = 3072  # in KB - 6 MB cache shared by two cores = 3MB/core
associativity = 24
replacement_policy = lru  # Not documented but I'm guessing pseudo-LRU
data_access_time = 15
tags_access_time = 4  # This is just a guess for Penryn
perf_model_type = parallel

[caching_protocol]
type = pr_l1_pr_l2_dram_directory_msi

[perf_model/dram_directory]
total_entries = 24576
associativity = 24
max_hw_sharers = 64 # number of sharers supported in hardware
directory_type = limited_broadcast # the name of the model to use for dram modeling
home_lookup_param = 8
directory_cache_access_time = 10

[perf_model/dram_directory/limitless]
software_trap_penalty = 200 # number of cycles added to clock when trapping into software (pulled number from Chaiken papers, which explores 25-150 cycle penalties)

[perf_model/dram]
latency = 75 # In nanoseconds
per_controller_bandwidth = 5 # In GB/s
num_controllers = -1 # Total Bandwidth = per_controller_bandwidth * num_controllers
controller_positions = ""
[perf_model/dram/queue_model]
enabled = true
type = history_list

[perf_model/branch_predictor]
type=one_bit
mispredict_penalty=14 # A guess based on Penryn pipeline depth
size=1024

# This describes the various models used for the different networks on the core

[network]
user_model_1 = hop_counter
user_model_2 = hop_counter
memory_model_1 = hop_counter
memory_model_2 = hop_counter
system_model = magic

# see comments in network_model_analytical.cc
[network/analytical]
Tw2 = 1
s = 1
n = 1
W = 32
update_interval = 1000
processing_cost = 100

[network/emesh_hop_by_hop]
link_bandwidth = 256 # In bits/cycle
hop_latency = 2 # In cycles
broadcast_tree_enabled = true
[network/emesh_hop_by_hop/queue_model]
enabled = true
type = history_list

[queue_model/basic]
moving_avg_enabled = false
moving_avg_window_size = 1024
moving_avg_type = arithmetic_mean

[queue_model/history_list]
# Uses the analytical model (if enabled) to calculate delay if cannot be calculated using the history list
max_list_size = 100
analytical_model_enabled = true

